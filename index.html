<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Athlete Injury Status Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #1a202c; color: #e2e8f0; }
        .container-bg { background-color: #2d3748; }
        .header-text { color: #edf2f7; }
        .secondary-text { color: #a0aec0; }
        .button-primary { background-color: #4a5568; color: #edf2f7; }
        .button-primary:hover { background-color: #718096; }
        .button-primary:disabled { background-color: #2d3748; color: #718096; cursor: not-allowed; }
        .grid-header { background-color: #2d3748; color: #a0aec0; }
        .athlete-name { background-color: #2d3748; color: #e2e8f0; }
        .status-box { transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .status-box:hover { transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .modal-content { background-color: #2d3748; }
        .input-field { background-color: #1a202c; border-color: #4a5568; color: #e2e8f0; }
        .input-field:focus { border-color: #718096; ring-color: #718096; }
        #tooltip { background-color: #1a202c; color: #e2e8f0; border: 1px solid #4a5568; z-index: 100; white-space: pre-wrap; max-width: 250px; }
        #tracker-grid { display: grid; grid-template-columns: 120px repeat(14, minmax(40px, 1fr)); gap: 1px; background-color: #4a5568; }
        @media (max-width: 768px) { #tracker-grid { grid-template-columns: 80px repeat(14, minmax(30px, 1fr)); } .grid-header, .athlete-name { font-size: 0.7rem; padding: 0.5rem; } }
    </style>
</head>
<body class="font-sans">

    <div class="container mx-auto p-2 sm:p-4">
        <header class="text-center my-6">
            <h1 class="text-3xl sm:text-4xl font-bold header-text">Athlete Injury Status Tracker</h1>
        </header>

        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 space-y-4 sm:space-y-0">
            <div class="flex space-x-2 w-full sm:w-auto">
                <button id="add-player-btn" class="w-1/2 sm:w-auto px-4 py-2 button-primary rounded-lg shadow">Add Player</button>
                <button id="delete-player-btn" class="w-1/2 sm:w-auto px-4 py-2 bg-red-800 text-white rounded-lg shadow hover:bg-red-700">Delete Player</button>
            </div>
            <div class="flex items-center space-x-2">
                <button id="prev-week" class="px-4 py-2 button-primary rounded-lg shadow">&lt;</button>
                <h2 id="date-range" class="text-lg sm:text-xl font-semibold text-center header-text w-48 sm:w-64"></h2>
                <button id="next-week" class="px-4 py-2 button-primary rounded-lg shadow">&gt;</button>
            </div>
            <button id="today-btn" class="w-full sm:w-auto px-4 py-2 button-primary rounded-lg shadow hidden">Today</button>
        </div>

        <div id="tracker-grid" class="overflow-x-auto container-bg rounded-lg shadow-lg">
            <!-- Grid will be populated by JavaScript -->
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4">
        <div class="modal-content rounded-lg shadow-2xl p-6 sm:p-8 w-full max-w-md">
            <h3 class="text-2xl font-bold mb-4 header-text" id="modal-title">Edit Status</h3>
            <form id="edit-form">
                <input type="hidden" id="edit-athlete-name">
                <input type="hidden" id="edit-date">
                <div class="mb-4"><label for="injury-site" class="block text-sm font-medium secondary-text mb-1">Injury Site</label><select id="injury-site" class="input-field w-full p-2 border rounded-lg"></select></div>
                <div class="mb-4"><label for="injury" class="block text-sm font-medium secondary-text mb-1">Injury</label><select id="injury" class="input-field w-full p-2 border rounded-lg"></select></div>
                <div class="mb-4"><label for="severity" class="block text-sm font-medium secondary-text mb-1">Severity</label><select id="severity" class="input-field w-full p-2 border rounded-lg"></select></div>
                <div class="mb-4"><label for="status" class="block text-sm font-medium secondary-text mb-1">Status</label><select id="status" class="input-field w-full p-2 border rounded-lg"></select></div>
                <div class="mb-6"><label for="comment" class="block text-sm font-medium secondary-text mb-1">Comment</label><textarea id="comment" rows="3" class="input-field w-full p-2 border rounded-lg"></textarea></div>
                <div class="flex justify-between items-center">
                    <button type="button" id="set-available-btn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Set Available</button>
                    <div class="space-x-3">
                        <button type="button" id="cancel-edit" class="px-4 py-2 bg-gray-600 text-gray-200 rounded-lg hover:bg-gray-700">Cancel</button>
                        <button type="submit" class="px-4 py-2 button-primary">Save</button>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Tooltip -->
    <div id="tooltip" class="absolute rounded-lg py-2 px-3 shadow-lg opacity-0 transition-opacity pointer-events-none"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const trackerGrid = document.getElementById('tracker-grid');
        const dateRangeEl = document.getElementById('date-range');
        const prevWeekBtn = document.getElementById('prev-week');
        const nextWeekBtn = document.getElementById('next-week');
        const todayBtn = document.getElementById('today-btn');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const deletePlayerBtn = document.getElementById('delete-player-btn');
        const modal = document.getElementById('edit-modal');
        const modalTitle = document.getElementById('modal-title');
        const editForm = document.getElementById('edit-form');
        const cancelBtn = document.getElementById('cancel-edit');
        const setAvailableBtn = document.getElementById('set-available-btn');
        const tooltip = document.getElementById('tooltip');

        let appData = {};
        let injuryLog = {};
        let currentEndDate = new Date();
        const seasonStartDate = new Date('2025-01-01T00:00:00');
        const isLocal = window.location.protocol === 'blob:';

        // --- FIXED INITIALIZATION SEQUENCE ---
        async function initializeApp() {
            // 1. Fetch both config and log data in parallel.
            const [config, log] = await Promise.all([
                fetchAppData(),
                fetchInjuryLog()
            ]);

            // 2. If either fetch fails (and we're not local), stop.
            if (!config || !log) {
                console.error("App initialization failed: Could not load required data.");
                return;
            }

            // 3. Assign the data to our state variables.
            appData = config;
            injuryLog = log;

            // 4. NOW that both data sources are loaded, check if a back-fill is needed.
            await backfillInitialData();
            
            // 5. Set up all the button clicks and other interactions.
            setupEventListeners();
            
            // 6. Finally, with all data present, render the grid for the first time.
            renderGrid();
        }

        async function fetchAppData() {
            try {
                const response = await fetch('/.netlify/functions/injury-log?config=true');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error("Error fetching app config:", error);
                if (isLocal) {
                    console.log("Local environment detected. Loading mock app config.");
                    return loadMockAppData(); // Return mock data
                } else {
                    trackerGrid.innerHTML = `<p class="text-red-400 p-4 col-span-full">Could not load app configuration.</p>`;
                    return null; // Return null on failure
                }
            }
        }

        async function fetchInjuryLog() {
            try {
                const response = await fetch('/.netlify/functions/injury-log');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error("Error fetching injury log:", error);
                if (isLocal) {
                    console.log("Local environment detected. Using empty injury log.");
                    return {}; // Return empty object for local
                }
                return null; // Return null on failure
            }
        }
        
        async function backfillInitialData() {
            if (isLocal) {
                console.log("Skipping back-fill in local environment.");
                return;
            }

            if (!appData.athletes || appData.athletes.length === 0) {
                return;
            }

            const athletesWithNoData = appData.athletes.filter(athlete => 
                !Object.keys(injuryLog).some(key => key.startsWith(athlete))
            );

            if (athletesWithNoData.length === 0) {
                console.log("All athletes have existing data. No back-fill needed.");
                return;
            }

            console.log("Back-filling data for new athletes:", athletesWithNoData.join(', '));

            let backfillPayload = [];
            const today = new Date();
            for (const athlete of athletesWithNoData) {
                for (let i = 0; i < 14; i++) {
                    const date = new Date(today);
                    date.setDate(today.getDate() - i);
                    if (date >= seasonStartDate) {
                        const key = `${athlete}-${toYYYYMMDD(date)}`;
                        backfillPayload.push({
                            key,
                            data: { status: 'Available', injurySite: '', injury: '', severity: '', comment: '' }
                        });
                    }
                }
            }
            
            if (backfillPayload.length > 0) {
                console.log(`Sending batch update with ${backfillPayload.length} entries.`);
                const result = await postData('/.netlify/functions/injury-log', { action: 'batchUpdateLog', payload: backfillPayload });
                if (result) {
                    // Refresh log data after back-filling
                    injuryLog = await fetchInjuryLog();
                }
            }
        }

        async function postData(endpoint, body) {
            if (isLocal) {
                alert("This action is disabled in the local preview. Please use the live Netlify URL to save data.");
                return null;
            }
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || `HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error posting to ${endpoint}:`, error);
                alert(`Failed to save update: ${error.message}`);
                return null;
            }
        }
        
        function loadMockAppData() {
            return {
                athletes: ["Bailey Sims", "Corey Hardy", "Cruz Martin", "Lachlan McNamara", "Lachlan Watt", "Luke Major", "Nick Perry", "Riley Martin", "Zach Taiba"],
                injurySites: ["Knee", "Ankle", "Shoulder", "Groin", "Back", "Hamstring", "Foot", "Head"],
                injuries: ["ACL Tear", "Sprain", "Dislocation", "Strain", "Pull"],
                severities: ["High", "Medium", "Low"],
                statuses: ["Out", "Modified", "Available"],
                colorMap: { "Out": "#D32F2F", "Modified": "#FFC107", "Available": "#4CAF50", "Pending": "#4A5568" }
            };
        }

        function renderGrid() {
            if (!appData.athletes || appData.athletes.length === 0) {
                trackerGrid.innerHTML = `<p class="text-gray-400 p-4 col-span-full text-center">Loading athlete data...</p>`;
                return;
            }
            trackerGrid.innerHTML = '';
            const dates = Array.from({ length: 14 }, (_, i) => {
                const date = new Date(currentEndDate);
                date.setDate(date.getDate() - (13 - i));
                return date;
            });

            const startDate = dates[0];
            dateRangeEl.textContent = `${formatDateDisplay(startDate)} - ${formatDateDisplay(currentEndDate)}`;
            
            const prevDateLimit = new Date(startDate);
            prevDateLimit.setDate(prevDateLimit.getDate() - 1);
            prevWeekBtn.disabled = prevDateLimit < seasonStartDate;

            const today = new Date();
            today.setHours(0,0,0,0);
            todayBtn.classList.toggle('hidden', currentEndDate.toDateString() === today.toDateString());

            trackerGrid.innerHTML += `<div class="grid-header sticky left-0 z-10 p-2">Athlete</div>`;
            dates.forEach(date => { trackerGrid.innerHTML += `<div class="grid-header">${formatDateHeader(date)}</div>`; });

            appData.athletes.forEach(athlete => {
                trackerGrid.innerHTML += `<div class="athlete-name sticky left-0 z-10 p-2">${athlete}</div>`;
                dates.forEach(date => {
                    const cellContent = (date < seasonStartDate)
                        ? `<div class="status-box" style="background-color: #1a202c; cursor: default;"></div>`
                        : createStatusBox(athlete, date);
                    trackerGrid.innerHTML += `<div class="p-1">${cellContent}</div>`;
                });
            });
            addBoxEventListeners();
        }

        function createStatusBox(athlete, date) {
            const statusData = getStatusForDate(athlete, date);
            const color = appData.colorMap[statusData.status] || '#4a5568';
            return `<div class="status-box rounded" 
                         style="background-color: ${color};"
                         data-athlete="${athlete}" 
                         data-date="${toYYYYMMDD(date)}"
                         data-status='${JSON.stringify(statusData)}'>
                    </div>`;
        }

        function getStatusForDate(athlete, dateToDisplay) {
            const key = `${athlete}-${toYYYYMMDD(dateToDisplay)}`;
            if (injuryLog[key]) return injuryLog[key];

            const today = new Date(); today.setHours(0, 0, 0, 0);
            const displayDay = new Date(dateToDisplay); displayDay.setHours(0, 0, 0, 0);

            if (displayDay > today) return { status: 'Pending' };

            let previousDate = new Date(dateToDisplay);
            while (previousDate > seasonStartDate) {
                previousDate.setDate(previousDate.getDate() - 1);
                const prevKey = `${athlete}-${toYYYYMMDD(previousDate)}`;
                if (injuryLog[prevKey]) return { ...injuryLog[prevKey] };
            }
            return { status: 'Available' };
        }

        function setupEventListeners() {
            prevWeekBtn.addEventListener('click', () => { currentEndDate.setDate(currentEndDate.getDate() - 14); renderGrid(); });
            nextWeekBtn.addEventListener('click', () => { currentEndDate.setDate(currentEndDate.getDate() + 14); renderGrid(); });
            todayBtn.addEventListener('click', () => { currentEndDate = new Date(); renderGrid(); });
            addPlayerBtn.addEventListener('click', handleAddPlayer);
            deletePlayerBtn.addEventListener('click', handleDeletePlayer);
            cancelBtn.addEventListener('click', () => modal.classList.add('hidden'));
            editForm.addEventListener('submit', handleFormSubmit);
            setAvailableBtn.addEventListener('click', handleSetAvailable);
        }

        function addBoxEventListeners() {
            document.querySelectorAll('.status-box').forEach(box => {
                box.addEventListener('dblclick', handleBoxDoubleClick);
                box.addEventListener('mouseover', handleMouseOver);
                box.addEventListener('mouseout', () => tooltip.style.opacity = '0');
                box.addEventListener('mousemove', e => { tooltip.style.left = `${e.pageX + 15}px`; tooltip.style.top = `${e.pageY + 15}px`; });
            });
        }

        async function handleAddPlayer() {
            const newName = prompt("Enter the new player's full name:");
            if (newName && newName.trim()) {
                const result = await postData('/.netlify/functions/injury-log', { action: 'addPlayer', name: newName.trim() });
                if (result) {
                    await initializeApp(); // Re-initialize the whole app to get new data and backfill
                }
            }
        }

        async function handleDeletePlayer() {
            const nameToDelete = prompt(`Enter the full name of the player to delete from this list:\n\n${appData.athletes.join('\n')}`);
            if (nameToDelete && nameToDelete.trim()) {
                const confirmed = confirm(`Are you sure you want to permanently delete ${nameToDelete} and all their data? This cannot be undone.`);
                if (confirmed) {
                    const result = await postData('/.netlify/functions/injury-log', { action: 'deletePlayer', name: nameToDelete.trim() });
                    if (result) {
                        await initializeApp(); // Re-initialize to refresh all data
                    }
                }
            }
        }

        function handleBoxDoubleClick(e) {
            const box = e.target;
            if (!box.dataset.status) return;
            const statusData = JSON.parse(box.dataset.status);
            if (statusData.status === 'Pending') return;
            
            const today = new Date(); today.setHours(0,0,0,0);
            const boxDate = new Date(box.dataset.date);
            if (boxDate > today) {
                alert("You cannot log an injury for a future date.");
                return;
            }

            modalTitle.textContent = `Update: ${box.dataset.athlete} on ${box.dataset.date}`;
            document.getElementById('edit-athlete-name').value = box.dataset.athlete;
            document.getElementById('edit-date').value = box.dataset.date;
            
            populateSelect('injury-site', appData.injurySites, statusData.injurySite);
            populateSelect('injury', appData.injuries, statusData.injury);
            populateSelect('severity', appData.severities, statusData.severity);
            populateSelect('status', appData.statuses, statusData.status);
            document.getElementById('comment').value = statusData.comment || '';
            modal.classList.remove('hidden');
        }

        async function handleFormSubmit(e) {
            e.preventDefault();
            const athlete = document.getElementById('edit-athlete-name').value;
            const date = document.getElementById('edit-date').value;
            const key = `${athlete}-${date}`;
            const newStatusData = {
                status: document.getElementById('status').value,
                injurySite: document.getElementById('injury-site').value,
                injury: document.getElementById('injury').value,
                severity: document.getElementById('severity').value,
                comment: document.getElementById('comment').value
            };
            const result = await postData('/.netlify/functions/injury-log', { action: 'updateLog', key, data: newStatusData });
            if (result) {
                injuryLog[key] = newStatusData;
                renderGrid();
                modal.classList.add('hidden');
            }
        }

        function handleSetAvailable() {
            document.getElementById('injury-site').value = '';
            document.getElementById('injury').value = '';
            document.getElementById('severity').value = '';
            document.getElementById('status').value = 'Available';
            document.getElementById('comment').value = '';
        }

        function handleMouseOver(e) {
            if (!e.target.dataset.status) return;
            const statusData = JSON.parse(e.target.dataset.status);
            if (statusData.status && statusData.status !== 'Available' && statusData.status !== 'Pending') {
                tooltip.textContent = `Status: ${statusData.status}\nInjury: ${statusData.injury || 'N/A'}\nSite: ${statusData.injurySite || 'N/A'}\nSeverity: ${statusData.severity || 'N/A'}\n\nComment: ${statusData.comment || 'None'}`;
                tooltip.style.opacity = '1';
            }
        }

        function toYYYYMMDD(date) { return new Date(date).toISOString().split('T')[0]; }
        function formatDateHeader(date) { const days = ['S', 'M', 'T', 'W', 'T', 'F', 'S']; return `${days[date.getDay()]}<br>${date.getDate()}`; }
        function formatDateDisplay(date) { return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }); }
        function populateSelect(elementId, options, selectedValue) {
            const select = document.getElementById(elementId);
            select.innerHTML = '<option value="">-- Select --</option>';
            options.forEach(option => {
                const isSelected = option === selectedValue ? 'selected' : '';
                select.innerHTML += `<option value="${option}" ${isSelected}>${option}</option>`;
            });
        }

        initializeApp();
    });
    </script>
</body>
</html>
